# 문제 : 효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는
# (1칸, 1칸, 1칸, 1칸)
# (1칸, 2칸, 1칸)
# (1칸, 1칸, 2칸)
# (2칸, 1칸, 1칸)
# (2칸, 2칸)
# 의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. 
# 멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 
# 여기에 1234567를 나눈 나머지를 리턴하는 함수, solution을 완성하세요. 예를 들어 4가 입력된다면, 5를 return하면 됩니다.

# 입출력 예)
# n = 4, result = 5
# n = 3, result = 3

from math import comb

def solution(n):
    answer = 0

    min_g = (n//2) + (n%2) 
    
    for i in range(min_g, n+1):
        answer += comb(i, n-i)

    return answer % 1234567

print(solution(4))
print(solution(3))


# 이해 : 
# 최대 숫자가 2라면 숫자들을 모두 1로 나누었을 때, 조합의 수에 맞춰서 2가 될 개수를 고르는 것과 같았다
# 예를 들어 5의 경우 1, 1, 1, 1, 1 에서
# 최대로 묶을 수 있는 그룹의 수는 (5//2) + (5%2) = 3개 이며
# 이경우 1, 1, 1 이렇게 3개 일 때 2개를 뽑아 2로 만들면 
# 첫 번째, 두 번째를 뽑아 2로 만들고 2, 2, 1, 두 번째, 세 번째를 뽑아 2로 만들고 1, 2, 2, 첫 번째, 세 번째를 뽑아 2로 만드는 2, 1, 2 세 경우가 있으며
# 이는 math의 comb 함수를 사용하여 comb(3, 2)의 결과와 같다
# 나머지 그룹에 대해서도 comb(4, 1), comb(5, 0)를 한 개수들을 모두 더했다


#  ---- 다른 사람 풀이 (재귀, dict 사용) ----
dic = {0:1,1:1}

def fibo(n):
    if n in dic:
        return dic[n] 

    dic[n] = fibo(n-2) + fibo(n-1)
    return dic[n]
      
def solution(n):
    answer = 0
    
    if n < 2:
        answer = n
        return answer
    else:
        answer = fibo(n)%1234567

    return answer

# 몇 가지 답을 구해보면 답이 피보나치 수열로 이루어져 있음을 알 수 있다. 일반 재귀함수를 사용하면 시간 초과가 나기 때문에
# dictionary에 값을 미리 저장해 놓으면 매번 연산을 반복하지 않아도 된다. 